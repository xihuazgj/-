# Springcloud相关学习笔记



Springboot + Mybatis-plus + docker + mysql + nginx + Springcloud + nacos（统一集群管理） + Openfeign（微服务之间的调用，使用它的拦截器以便在微服务之间传递信息）+sentinel(服务监控，服务限流，服务隔离，服务熔断)+seata(分布式事务，两种模式：XA和AT模式，XA遵循的是强一致性，服务之间会等待每个事务执行完毕才能提交，失败则一起回滚，消耗时间；AT模式是最终一致性，会经过两个阶段，第一阶段根据事务需求生成快照（undo log），第二阶段根据事务执行情况，若成功，则删除快照，结束，失败则通过快照进行数据恢复，回滚。中间会出现一段时间的数据不一致)+RabbitMQ（消息转发的作用，exchages只负责转发（路由，路由失败，消息就会丢失，交换机只会路由信息给与其绑定的队列，因此队列必须与交换机绑定），没有存储消息的作用。RabbitMQ拥有数据隔离的功能）







事务（Transaction）是一个核心概念。事务的四个特性，通常被称为ACID特性，是确保数据库操作可靠性和一致性的基石。这四个特性分别是：

1. **原子性（Atomicity）**：
   原子性指的是事务中的操作要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误会被回滚（Rollback）到事务开始前的状态，就像这个事务从未执行过一样。
2. **一致性（Consistency）**：
   一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态。事务的结束不会破坏数据库的完整性约束，并且所有相关的数据规则都必须得到满足。
3. **隔离性（Isolation）**：
   隔离性是指数据库系统提供一定的隔离级别，使得事务在不受外部并发操作影响的“独立”环境中运行。这意味着事务处理过程中的中间状态对外部是不可见的，或者说，事务不可分割地执行，不会被其他事务干扰。不同的隔离级别可以防止不同的并发问题，如脏读、不可重复读和幻读。
4. **持久性（Durability）**：
   持久性是指一旦事务被提交，它对数据库的修改就是永久性的，即使系统发生故障也不会丢失。即使发生系统崩溃，数据库也能通过日志文件等机制恢复到最后一次提交的状态。

## 悲观锁与乐观锁

### 一、定义与思想

- **悲观锁（Pessimistic Locking）**：悲观锁假设在事务执行期间，其他事务很可能会对共享资源进行修改，因此默认情况下会将资源锁定，以阻止其他事务的访问。它适用于对数据访问频率高、竞争激烈的情况。
- **乐观锁（Optimistic Locking）**：乐观锁则假设在事务执行期间，不会有其他事务对共享资源进行修改，因此不会对资源进行锁定。其核心思想是在事务读取数据时记录下当前的版本号或时间戳，然后在更新数据时检查这个版本号或时间戳是否发生变化。

### 二、实现方式

- 悲观锁
  - **数据库层面**：如MySQL中的排他锁（SELECT ... FOR UPDATE），可以锁定所选行，确保其他事务无法修改这些行直到锁被释放。
  - **代码层面**：如Java中的synchronized关键字，可以对代码块进行加锁，防止多个线程同时执行。
- 乐观锁
  - **版本号机制**：在数据中增加一个version字段，每次数据被修改时版本号加1。更新数据时检查版本号是否一致，一致则执行更新，不一致则放弃或重新尝试。
  - **CAS（Compare and Swap）机制**：涉及三个操作数，内存位置（V）、预期值（A）和新值（B）。如果内存位置的值等于预期值，则将其更新为新值，否则不操作。

### 三、应用场景

- **悲观锁**：适合用在写操作多、竞争激烈的场景中，如金融交易系统、库存管理系统等。这些系统对数据的一致性和完整性要求极高，需要通过加锁来确保数据的正确性。
- **乐观锁**：适合用在读操作多、写操作少且并发冲突概率较小的场景中，如博客系统、新闻网站等。这些系统对数据的实时性要求不高，可以通过乐观锁来提高系统的并发性能。

### 四、优缺点

- 悲观锁
  - **优点**：能够确保数据的一致性和完整性，避免数据冲突。
  - **缺点**：可能会降低系统的并发性能，因为其他事务需要等待锁被释放才能访问数据。此外，加锁和释放锁也需要消耗系统资源。
- 乐观锁
  - **优点**：不会阻塞其他事务的读取操作，提高了系统的并发性能。同时，由于不需要加锁和释放锁，也减少了系统资源的消耗。
  - **缺点**：在并发冲突概率较高的场景中，乐观锁可能会因为数据被反复修改而更新失败，导致CPU资源的浪费。此外，乐观锁的实现需要依赖于业务逻辑，增加了实现的复杂度。

